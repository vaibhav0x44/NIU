<!DOCTYPE html>
<html>
<head>
    <title style="color: blue;">Java OOP Exam Preparation - Complete Question Bank</title>

    <style>
    body {
        background-color: black;
        color: white;
        font-family: Arial, sans-serif;
        line-height: 1.6;
    }

    .question {
        color: red;
        font-weight: bold;
    }

    .answer {
        color: Cyan;
    }

    h1, h2, h3 {
        color: magenta;
    }

    .unit {
        margin-bottom: 30px;
        border-bottom: 2px solid #ccc;
        padding-bottom: 20px;
    }
</style>

<body>
    <h1>NOIDA INTERNATIONAL UNIVERSITY</h1>
    <h2>School of Sciences (SOS)</h2>
    <h3>Department of Computer Science</h3>

    <div class="unit">
        <h2>Unit 1: Java Fundamentals</h2>

        <p class="question">1. What are the key milestones in the history of Java programming language development, and how has it evolved over time?</p>
        <p class="answer">- 1991: Started as Oak project by James Gosling at Sun Microsystems<br>
        - 1995: Officially renamed to Java and Java 1.0 released<br>
        - 1998: Java 2 (J2SE, J2EE, J2ME introduced)<br>
        - 2004: Java 5 (major features: generics, autoboxing, annotations)<br>
        - 2014: Java 8 (Lambda expressions, Stream API)<br>
        - 2017: Java 9 (Module system)<br>
        - Evolution: From applets to enterprise applications, mobile (Android), and now cloud computing</p>

        <p class="question">2. Discuss some of the prominent features of Java that distinguish it from other programming languages.</p>
        <p class="answer">- Platform Independent: Write Once Run Anywhere (WORA) via bytecode and JVM<br>
        - Object-Oriented: Everything is an object except primitives<br>
        - Robust: Strong memory management, exception handling, type checking<br>
        - Secure: No pointers, bytecode verification, sandbox security model<br>
        - Multithreaded: Built-in support for concurrent programming<br>
        - Dynamic: Reflection, runtime type information<br>
        - Distributed: Network-centric design with RMI and sockets</p>

        <p class="question">3. Highlight the main differences between Java and C++, focusing on their syntax, features, and paradigms.</p>
        <p class="answer">- Memory Management: Java has automatic garbage collection, C++ requires manual<br>
        - Pointers: Java has references but no explicit pointers like C++<br>
        - Multiple Inheritance: Java uses interfaces instead of multiple class inheritance<br>
        - Platform: Java is platform-independent, C++ is platform-dependent<br>
        - Runtime: Java runs on JVM, C++ compiles to native code<br>
        - Standard Library: Java has more extensive built-in libraries<br>
        - Performance: C++ is generally faster as it's compiled to native code</p>

        <p class="question">4. Explain the architecture of Java, including the roles of JDK, JVM, and JRE in the Java ecosystem.</p>
        <p class="answer">- JDK (Java Development Kit): Tools for developing Java programs (javac, java, javadoc)<br>
        - JRE (Java Runtime Environment): Provides libraries and JVM to run Java programs<br>
        - JVM (Java Virtual Machine): Executes bytecode, provides platform independence<br>
        - Architecture Flow: Java Source (.java) → Compiler (javac) → Bytecode (.class) → JVM → Machine Code<br>
        - JVM Components: Classloader, Bytecode Verifier, Interpreter/JIT, Runtime Data Areas</p>

        <p class="question">5. What are Java tokens, and what categories do they include? Discuss data types, literals, variables, and operators in Java.</p>
        <p class="answer">- Tokens: Smallest individual elements in a program<br>
        Categories:<br>
        - Keywords (final, static, class)<br>
        - Identifiers (class/variable names)<br>
        - Literals (fixed values: 100, 'A', "Hello")<br>
        - Operators (+, -, *, /, %, =, ==)<br>
        - Separators ({}, [], ;, ,)<br>
        Data Types:<br>
        - Primitive (byte, short, int, long, float, double, char, boolean)<br>
        - Reference (objects, arrays)<br>
        Variables: Named memory locations (declaration: type name; initialization: name = value)</p>

        <p class="question">6. Describe the scope and lifetime of variables in Java, including local, instance, and class variables.</p>
        <p class="answer">- Local Variables:<br>
        &nbsp;&nbsp;Scope: Within the block/method where declared<br>
        &nbsp;&nbsp;Lifetime: Until the block/method completes<br>
        - Instance Variables:<br>
        &nbsp;&nbsp;Scope: Throughout the class (non-static fields)<br>
        &nbsp;&nbsp;Lifetime: As long as the object exists<br>
        - Class Variables (static):<br>
        &nbsp;&nbsp;Scope: Throughout the class and accessible via class name<br>
        &nbsp;&nbsp;Lifetime: Entire program execution<br>
        Key Points:<br>
        - Local variables must be initialized before use<br>
        - Instance variables get default values<br>
        - Static variables are shared among all instances</p>

        <p class="question">7. How are control structures used in Java for decision-making and looping? Provide examples.</p>
        <p class="answer">Decision Making:<br>
        - if-else: if(condition) { ... } else { ... }<br>
        - switch: switch(var) { case 1: ... break; default: ... }<br>
        Looping:<br>
        - for: for(int i=0; i<10; i++) { ... }<br>
        - while: while(condition) { ... }<br>
        - do-while: do { ... } while(condition);<br>
        Examples:<br>
        // Decision<br>
        if(age >= 18) {<br>
        &nbsp;&nbsp;System.out.println("Adult");<br>
        } else {<br>
        &nbsp;&nbsp;System.out.println("Minor");<br>
        }<br>
        // Looping<br>
        for(int i=1; i<=5; i++) {<br>
        &nbsp;&nbsp;System.out.println(i);<br>
        }</p>

        <p class="question">8. Explain the concept of arrays in Java, including their declaration, initialization, and usage.</p>
        <p class="answer">- Array: Fixed-size collection of same-type elements<br>
        Declaration:<br>
        &nbsp;&nbsp;type[] arrayName; (preferred)<br>
        &nbsp;&nbsp;or type arrayName[];<br>
        Initialization:<br>
        &nbsp;&nbsp;arrayName = new type[size];<br>
        &nbsp;&nbsp;or type[] arrayName = {val1, val2, val3};<br>
        Usage:<br>
        - Access: arrayName[index] (0-based)<br>
        - Length: arrayName.length<br>
        Example:<br>
        int[] numbers = new int[3];<br>
        numbers[0] = 10;<br>
        numbers[1] = 20;<br>
        numbers[2] = 30;<br>
        for(int num : numbers) {<br>
        &nbsp;&nbsp;System.out.println(num);<br>
        }</p>

        <p class="question">9. Introduce the concept of classes in Java programming. How do you create a class, and what are its components?</p>
        <p class="answer">- Class: Blueprint/template for creating objects<br>
        Components:<br>
        - Fields (variables representing state)<br>
        - Methods (functions representing behavior)<br>
        - Constructors (special methods for object initialization)<br>
        - Blocks (static and instance initializers)<br>
        - Nested classes/interfaces<br>
        Syntax:<br>
        [access-modifier] class ClassName {<br>
        &nbsp;&nbsp;// fields<br>
        &nbsp;&nbsp;type fieldName;<br>
        &nbsp;&nbsp;// constructor<br>
        &nbsp;&nbsp;ClassName() { ... }<br>
        &nbsp;&nbsp;// methods<br>
        &nbsp;&nbsp;returnType methodName(params) { ... }<br>
        }<br>
        Example:<br>
        public class Student {<br>
        &nbsp;&nbsp;String name;<br>
        &nbsp;&nbsp;int rollNo;<br>
        &nbsp;&nbsp;public Student(String n, int r) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;name = n;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;rollNo = r;<br>
        &nbsp;&nbsp;}<br>
        &nbsp;&nbsp;public void display() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name+" "+rollNo);<br>
        &nbsp;&nbsp;}<br>
        }</p>

        <p class="question">10. Discuss the properties, methods, and constructors of a Java class and their significance in object-oriented programming.</p>
        <p class="answer">- Properties (Fields):<br>
        &nbsp;&nbsp;Represent object state<br>
        &nbsp;&nbsp;Should usually be private (encapsulation)<br>
        &nbsp;&nbsp;Accessed via getters/setters<br>
        - Methods:<br>
        &nbsp;&nbsp;Define object behavior<br>
        &nbsp;&nbsp;Can be instance or static<br>
        &nbsp;&nbsp;Enable code reuse and modularity<br>
        - Constructors:<br>
        &nbsp;&nbsp;Special methods with same name as class<br>
        &nbsp;&nbsp;No return type<br>
        &nbsp;&nbsp;Initialize object state<br>
        &nbsp;&nbsp;Default constructor provided if none defined<br>
        &nbsp;&nbsp;Can be overloaded<br>
        Significance in OOP:<br>
        - Encapsulation: Fields private, methods public<br>
        - Abstraction: Hide implementation details<br>
        - Modularity: Organize related data and behavior</p>

        <p class="question">11. What are access modifiers in Java, and how do they control the accessibility of class members?</p>
        <p class="answer">- public: Accessible from any class<br>
        - protected: Accessible within package and subclasses (even in other packages)<br>
        - default (no modifier): Accessible only within the same package<br>
        - private: Accessible only within the same class<br>
        Accessibility Table:<br>
        | Modifier  | Class | Package | Subclass | World |<br>
        |-----------|-------|---------|----------|-------|<br>
        | public    | Yes   | Yes     | Yes      | Yes   |<br>
        | protected | Yes   | Yes     | Yes      | No    |<br>
        | default   | Yes   | Yes     | No       | No    |<br>
        | private   | Yes   | No      | No       | No    |<br>
        Best Practices:<br>
        - Fields should usually be private<br>
        - Methods that need external access should be public<br>
        - Use protected for inheritance scenarios</p>

        <p class="question">12. Explain method overloading in Java and provide examples demonstrating its usage.</p>
        <p class="answer">- Method Overloading: Multiple methods with same name but different parameters<br>
        Differences can be in:<br>
        - Number of parameters<br>
        - Type of parameters<br>
        - Sequence of parameters<br>
        Cannot overload based on:<br>
        - Return type alone<br>
        - Exception thrown<br>
        Examples:<br>
        // Different parameter types<br>
        void display(int a) { ... }<br>
        void display(String s) { ... }<br>
        // Different number of parameters<br>
        int add(int a, int b) { return a+b; }<br>
        int add(int a, int b, int c) { return a+b+c; }<br>
        // Different sequence<br>
        void show(int a, String b) { ... }<br>
        void show(String a, int b) { ... }<br>
        Benefits:<br>
        - Improves readability<br>
        - Provides flexibility in method calling</p>

        <p class="question">13. Describe the process of garbage collection in Java and its role in managing memory.</p>
        <p class="answer">- Garbage Collection: Automatic memory management<br>
        Process:<br>
        1. Identify unreachable objects (no references pointing to them)<br>
        2. Mark them for collection<br>
        3. Reclaim memory (done by garbage collector)<br>
        Types of GC in Java:<br>
        - Serial GC (single thread)<br>
        - Parallel GC (multiple threads)<br>
        - CMS (Concurrent Mark Sweep)<br>
        - G1 (Garbage First) - default since Java 9<br>
        Role in Memory Management:<br>
        - Prevents memory leaks<br>
        - Automates memory deallocation<br>
        - Runs in background (can be triggered manually via System.gc())<br>
        Important Notes:<br>
        - GC only works for heap memory (objects)<br>
        - Doesn't guarantee immediate collection<br>
        - finalize() method called before collection (but deprecated since Java 9)</p>

        <p class="question">14. Discuss the significance of the "this" keyword in Java and its usage within classes and methods.</p>
        <p class="answer">- 'this' keyword refers to current object instance<br>
        Usages:<br>
        1. Resolve name ambiguity between instance variables and parameters:<br>
        &nbsp;&nbsp;public Student(String name) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;this.name = name; // this.name = instance variable<br>
        &nbsp;&nbsp;}<br>
        2. Call another constructor of same class (constructor chaining):<br>
        &nbsp;&nbsp;public Student() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;this("Unknown"); // calls parameterized constructor<br>
        &nbsp;&nbsp;}<br>
        3. Pass current object as parameter:<br>
        &nbsp;&nbsp;method(this);<br>
        4. Return current object from method:<br>
        &nbsp;&nbsp;return this;<br>
        Significance:<br>
        - Improves code clarity<br>
        - Enables constructor reuse<br>
        - Essential for method chaining patterns</p>

        <p class="question">15. What is the purpose of static variables, methods, and blocks in Java? How do they differ from instance members?</p>
        <p class="answer">- Static Members: Belong to class rather than instances<br>
        Static Variable:<br>
        - Single copy shared by all instances<br>
        - Accessed via ClassName.variableName<br>
        Static Method:<br>
        - Can be called without object instantiation<br>
        - Can only access static members directly<br>
        Static Block:<br>
        - Executed when class is loaded<br>
        - Used for static initialization<br>
        Differences from Instance Members:<br>
        | Feature        | Static                     | Instance                   |<br>
        |----------------|----------------------------|----------------------------|<br>
        | Memory         | Single copy                | Separate per object        |<br>
        | Access         | Via class name             | Via object reference       |<br>
        | Can access     | Only static members        | Both static and instance   |<br>
        | Lifetime       | Class loading to unloading | Object creation to garbage collection |<br>
        Example:<br>
        class Counter {<br>
        &nbsp;&nbsp;static int count = 0; // shared<br>
        &nbsp;&nbsp;int id; // per instance<br>
        &nbsp;&nbsp;static { count = 100; } // static block<br>
        &nbsp;&nbsp;public static void printCount() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(count);<br>
        &nbsp;&nbsp;}<br>
        }</p>
    </div>

    <div class="unit">
        <h2>Unit 2: Inheritance and Polymorphism</h2>

        <p class="question">1. What are the different types of inheritance in Java, and how do they facilitate code reuse?</p>
        <p class="answer">- Single Inheritance: Class extends one superclass (A → B)<br>
        - Multilevel Inheritance: Chain of inheritance (A → B → C)<br>
        - Hierarchical Inheritance: Multiple subclasses from one superclass (A → B, A → C)<br>
        - Multiple Inheritance: Not supported directly in classes (but via interfaces)<br>
        - Hybrid Inheritance: Combination of above (not common in Java)<br>
        Code Reuse Benefits:<br>
        - Avoids code duplication<br>
        - Promotes modularity<br>
        - Establishes logical "is-a" relationships<br>
        - Enables method overriding for polymorphism<br>
        Example:<br>
        class Animal { void eat() { ... } }<br>
        class Dog extends Animal { // single inheritance<br>
        &nbsp;&nbsp;void bark() { ... }<br>
        }</p>

        <p class="question">2. Explain the role of the "super" keyword in Java inheritance and provide examples of its usage.</p>
        <p class="answer">- 'super' keyword refers to immediate parent class<br>
        Usages:<br>
        1. Access parent class fields/methods (when hidden by child):<br>
        &nbsp;&nbsp;super.variableName;<br>
        &nbsp;&nbsp;super.methodName();<br>
        2. Call parent class constructor (must be first statement):<br>
        &nbsp;&nbsp;super(); // default constructor<br>
        &nbsp;&nbsp;super(params); // parameterized constructor<br>
        Example:<br>
        class Parent {<br>
        &nbsp;&nbsp;String name = "Parent";<br>
        &nbsp;&nbsp;void show() { System.out.println("Parent method"); }<br>
        }<br>
        class Child extends Parent {<br>
        &nbsp;&nbsp;String name = "Child";<br>
        &nbsp;&nbsp;void show() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;super.show(); // calls parent method<br>
        &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(super.name); // prints "Parent"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(name); // prints "Child"<br>
        &nbsp;&nbsp;}<br>
        }</p>

        <p class="question">3. Discuss the concept of method overriding in Java, including its significance in object-oriented programming.</p>
        <p class="answer">- Method Overriding: Subclass provides specific implementation of method already defined in superclass<br>
        Rules:<br>
        - Same method name and parameters<br>
        - Return type should be same or covariant<br>
        - Access modifier cannot be more restrictive<br>
        - Cannot override final/private/static methods<br>
        - Can throw same, subclass or no exception (but not broader)<br>
        Significance in OOP:<br>
        - Enables runtime polymorphism<br>
        - Implements "one interface, multiple implementations"<br>
        - Supports abstraction and dynamic method dispatch<br>
        Example:<br>
        class Bank {<br>
        &nbsp;&nbsp;float getRate() { return 0; }<br>
        }<br>
        class SBI extends Bank {<br>
        &nbsp;&nbsp;float getRate() { return 8.4f; } // overriding<br>
        }<br>
        class ICICI extends Bank {<br>
        &nbsp;&nbsp;float getRate() { return 7.3f; } // overriding<br>
        }</p>

        <p class="question">4. What is a covariant return type in Java, and how does it relate to method overriding?</p>
        <p class="answer">- Covariant Return Type: Allows overriding method to return subclass of original return type<br>
        Introduced in Java 5<br>
        Rules:<br>
        - Only applies to non-primitive return types<br>
        - Overriding method's return type must be subtype of overridden method's return type<br>
        Example:<br>
        class A { }<br>
        class B extends A { }<br>
        class Parent {<br>
        &nbsp;&nbsp;A get() { return new A(); }<br>
        }<br>
        class Child extends Parent {<br>
        &nbsp;&nbsp;B get() { return new B(); } // covariant return<br>
        }<br>
        Benefits:<br>
        - More specific return types in subclasses<br>
        - Maintains type safety<br>
        - Reduces need for type casting</p>

        <p class="question">5. Describe the process of creating and implementing an interface in Java, including the syntax involved.</p>
        <p class="answer">- Interface: Blueprint of class (100% abstract before Java 8)<br>
        Creating Interface:<br>
        [access-modifier] interface InterfaceName {<br>
        &nbsp;&nbsp;// constant fields (public static final by default)<br>
        &nbsp;&nbsp;type CONSTANT_NAME = value;<br>
        &nbsp;&nbsp;// abstract methods (public abstract by default)<br>
        &nbsp;&nbsp;returnType methodName(params);<br>
        &nbsp;&nbsp;// default methods (Java 8+)<br>
        &nbsp;&nbsp;default returnType methodName(params) { ... }<br>
        &nbsp;&nbsp;// static methods (Java 8+)<br>
        &nbsp;&nbsp;static returnType methodName(params) { ... }<br>
        }<br>
        Implementing Interface:<br>
        class ClassName implements InterfaceName {<br>
        &nbsp;&nbsp;// must implement all abstract methods<br>
        &nbsp;&nbsp;@Override<br>
        &nbsp;&nbsp;public returnType methodName(params) { ... }<br>
        }<br>
        Example:<br>
        interface Drawable {<br>
        &nbsp;&nbsp;void draw();<br>
        &nbsp;&nbsp;default void print() { System.out.println("Printing"); }<br>
        }<br>
        class Circle implements Drawable {<br>
        &nbsp;&nbsp;public void draw() { System.out.println("Drawing circle"); }<br>
        }</p>

        <p class="question">6. What are the key differences between an abstract class and an interface in Java?</p>
        <p class="answer">| Feature          | Abstract Class                     | Interface                          |<br>
        |-----------------|------------------------------------|------------------------------------|<br>
        | Keyword         | abstract class                     | interface                          |<br>
        | Instantiation   | Cannot be instantiated             | Cannot be instantiated             |<br>
        | Methods         | Can have abstract + concrete       | All abstract (before Java 8)       |<br>
        | Variables       | Can have any type of variables     | Only public static final constants |<br>
        | Inheritance     | Single inheritance                 | Multiple inheritance supported     |<br>
        | Constructors    | Can have constructors              | No constructors                    |<br>
        | Access Modifiers| Can have any access modifier       | Implicitly public                  |<br>
        | Default Methods | Not applicable                     | Supported since Java 8             |<br>
        | Static Methods  | Supported                          | Supported since Java 8             |<br>
        | When to Use     | Share code among related classes   | Define contract for unrelated classes |<br>
        Example:<br>
        abstract class Animal {<br>
        &nbsp;&nbsp;abstract void sound();<br>
        &nbsp;&nbsp;void breathe() { System.out.println("Breathing"); }<br>
        }<br>
        interface Movable {<br>
        &nbsp;&nbsp;void move();<br>
        }</p>

        <p class="question">7. Explain the purpose of packages in Java, and how are they used to organize and manage classes.</p>
        <p class="answer">- Package: Namespace for organizing related classes/interfaces<br>
        Purposes:<br>
        - Prevent naming conflicts<br>
        - Provide access control (package-private)<br>
        - Make classes easier to find/use<br>
        - Enable modular programming<br>
        Organization:<br>
        - Follow reverse domain name convention (com.example.mypackage)<br>
        - Directory structure mirrors package hierarchy<br>
        Usage:<br>
        - Declare package: package com.example.mypackage;<br>
        - Import packages: import java.util.*; or import java.util.ArrayList;<br>
        Types:<br>
        - Built-in (java.lang, java.util, java.io etc.)<br>
        - User-defined<br>
        Benefits:<br>
        - Better project structure<br>
        - Improved maintainability<br>
        - Access control (protected and default visibility)</p>

        <p class="question">8. How do you import a package in Java, and what is the syntax for doing so?</p>
        <p class="answer">Import Syntax:<br>
        - Import single class: import package.subpackage.ClassName;<br>
        - Import all classes from package: import package.subpackage.*;<br>
        - Static import (for static members): import static package.Class.staticMember;<br>
        Notes:<br>
        - java.lang package is automatically imported<br>
        - Can use fully qualified name without importing (java.util.ArrayList list = ...)<br>
        Examples:<br>
        import java.util.ArrayList; // imports only ArrayList<br>
        import java.util.*; // imports all from java.util<br>
        import static java.lang.Math.PI; // static import<br>
        Import Rules:<br>
        - Must appear after package statement (if any)<br>
        - Before class declaration<br>
        - No circular dependencies allowed</p>

        <p class="question">9. What is the Exception class in Java, and how does it relate to exception handling?</p>
        <p class="answer">- Exception Class: Root class in exception hierarchy (java.lang.Exception)<br>
        Hierarchy:<br>
        Throwable (superclass)<br>
        ├── Exception (checked exceptions)<br>
        │   ├── RuntimeException (unchecked)<br>
        │   └── Other checked exceptions (IOException, SQLException etc.)<br>
        └── Error (serious system errors - unchecked)<br>
        Exception Handling:<br>
        - try: Contains code that might throw exception<br>
        - catch: Handles specific exception types<br>
        - finally: Always executes (cleanup code)<br>
        - throw: Explicitly throws exception<br>
        - throws: Declares exceptions a method might throw<br>
        Example:<br>
        try {<br>
        &nbsp;&nbsp;FileReader file = new FileReader("test.txt");<br>
        } catch(FileNotFoundException e) {<br>
        &nbsp;&nbsp;System.out.println("File not found");<br>
        } finally {<br>
        &nbsp;&nbsp;System.out.println("Cleanup");<br>
        }</p>

        <p class="question">10. Differentiate between built-in checked and unchecked exceptions in Java, providing examples of each.</p>
        <p class="answer">Checked Exceptions:<br>
        - Checked at compile-time<br>
        - Must be handled (try-catch) or declared (throws)<br>
        - Subclasses of Exception (but not RuntimeException)<br>
        Examples:<br>
        - IOException (FileNotFoundException, EOFException)<br>
        - SQLException<br>
        - ClassNotFoundException<br>
        Unchecked Exceptions:<br>
        - Not checked at compile-time<br>
        - Subclasses of RuntimeException<br>
        Examples:<br>
        - NullPointerException<br>
        - ArrayIndexOutOfBoundsException<br>
        - ArithmeticException<br>
        - IllegalArgumentException<br>
        Key Differences:<br>
        | Aspect         | Checked Exceptions               | Unchecked Exceptions              |<br>
        |----------------|----------------------------------|-----------------------------------|<br>
        | Compile Check  | Yes                              | No                                |<br>
        | Handling       | Must be handled/declared         | Optional                          |<br>
        | Inheritance    | Extends Exception                | Extends RuntimeException          |<br>
        | Nature         | External conditions              | Programming errors                |</p>

        <p class="question">11. How can you define user-defined exceptions in Java, and what are the best practices for doing so?</p>
        <p class="answer">Defining Custom Exceptions:<br>
        1. Extend Exception (for checked) or RuntimeException (for unchecked)<br>
        2. Provide constructors (at least no-arg and string parameter)<br>
        Example:<br>
        class MyException extends Exception {<br>
        &nbsp;&nbsp;public MyException() {}<br>
        &nbsp;&nbsp;public MyException(String msg) { super(msg); }<br>
        }<br>
        Best Practices:<br>
        - End class name with "Exception"<br>
        - Provide useful error messages<br>
        - Include constructors matching superclass<br>
        - Document exceptions using @throws in JavaDoc<br>
        - Prefer unchecked exceptions for programming errors<br>
        - Use checked exceptions for recoverable conditions<br>
        - Include original exception when wrapping (cause parameter)<br>
        Usage Example:<br>
        void validate(int age) throws MyException {<br>
        &nbsp;&nbsp;if(age < 18) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;throw new MyException("Age must be >= 18");<br>
        &nbsp;&nbsp;}<br>
        }</p>

        <p class="question">12. Explain the use of the try-catch block in Java exception handling and provide examples of its usage.</p>
        <p class="answer">- try Block: Contains code that might throw exceptions<br>
        - catch Block: Handles specific exception types<br>
        Syntax:<br>
        try {<br>
        &nbsp;&nbsp;// risky code<br>
        } catch(ExceptionType1 e1) {<br>
        &nbsp;&nbsp;// handle ExceptionType1<br>
        } catch(ExceptionType2 e2) {<br>
        &nbsp;&nbsp;// handle ExceptionType2<br>
        }<br>
        Features:<br>
        - Multiple catch blocks allowed (more specific first)<br>
        - Multi-catch (Java 7+): catch(Ex1 | Ex2 e)<br>
        - Can access exception info via exception object (e.getMessage(), e.printStackTrace())<br>
        Examples:<br>
        // Basic try-catch<br>
        try {<br>
        &nbsp;&nbsp;int result = 10 / 0;<br>
        } catch(ArithmeticException e) {<br>
        &nbsp;&nbsp;System.out.println("Cannot divide by zero");<br>
        }<br>
        // Multiple catch<br>
        try {<br>
        &nbsp;&nbsp;int[] arr = new int[5];<br>
        &nbsp;&nbsp;arr[10] = 50;<br>
        } catch(ArrayIndexOutOfBoundsException e) {<br>
        &nbsp;&nbsp;System.out.println("Array index invalid");<br>
        } catch(Exception e) {<br>
        &nbsp;&nbsp;System.out.println("Generic error");<br>
        }</p>

         <p class="question">13. Describe the purpose of the "throw" keyword in Java exception handling, and when is it typically used?</p>
        <p class="answer">- <strong>Purpose</strong>: The <code class="code">throw</code> keyword is used to explicitly raise an exception in Java<br>
        - <strong>Key Uses</strong>:<br>
        &nbsp;&nbsp;1. To signal error conditions in your code<br>
        &nbsp;&nbsp;2. To convert checked exceptions to unchecked when appropriate<br>
        &nbsp;&nbsp;3. To throw custom exceptions for business rules<br>
        <br>
        <strong>When to Use</strong>:<br>
        1. Input validation failures<br>
        <span class="code">if(age < 18) throw new IllegalArgumentException("Age must be ≥18");</span><br>
        2. Unrecoverable application states<br>
        3. When wrapping low-level exceptions<br>
        <span class="code">throw new ServiceException("Database error", sqlEx);</span><br>
        4. In stub methods that aren't implemented yet<br>
        <br>
        <strong>Memory Trick</strong>:<br>
        - "throw" is like raising your hand to say "Problem!"<br>
        - Always creates a <u>new</u> exception object</p>

        <p class="question">14. What is the significance of the "throws" keyword in Java exception handling, and how does it affect method signatures?</p>
        <p class="answer">- <strong>Purpose</strong>: <code class="code">throws</code> declares which exceptions a method might propagate<br>
        - <strong>Effects</strong>:<br>
        &nbsp;&nbsp;1. Makes exception handling part of method contract<br>
        &nbsp;&nbsp;2. Forces callers to handle or declare checked exceptions<br>
        &nbsp;&nbsp;3. Documents potential failures in method signature<br>
        <br>
        <strong>Example</strong>:<br>
        <span class="code">public void loadConfig(String path) throws FileNotFoundException, SecurityException { ... }</span><br>
        <br>
        <strong>Key Rules</strong>:<br>
        1. Only needed for checked exceptions<br>
        2. Subclass methods can declare fewer exceptions than superclass<br>
        3. Unchecked exceptions (RuntimeException) don't need declaration<br>
        <br>
        <strong>Memory Trick</strong>:<br>
        - "throws" is like a warning label on a method<br>
        - Compare with:<br>
        &nbsp;&nbsp;- <code class="code">throw</code> = actually throwing a ball (exception)<br>
        &nbsp;&nbsp;- <code class="code">throws</code> = saying you might throw</p>

        <p class="question">15. Discuss the role of the "finally" block in Java exception handling and its importance in resource management.</p>
        <p class="answer">- <strong>Purpose</strong>: <code class="code">finally</code> ensures cleanup code always executes<br>
        - <strong>Guarantees</strong>: Runs whether:<br>
        &nbsp;&nbsp;1. try succeeds<br>
        &nbsp;&nbsp;2. catch handles exception<br>
        &nbsp;&nbsp;3. Exception propagates<br>
        &nbsp;&nbsp;4. return/break/continue occurs<br>
        <br>
        <strong>Resource Management</strong>:<br>
        // Traditional approach<br>
        <span class="code">BufferedReader br = null;<br>
        try {<br>
        &nbsp;&nbsp;br = new BufferedReader(new FileReader("file.txt"));<br>
        &nbsp;&nbsp;// read file<br>
        } finally {<br>
        &nbsp;&nbsp;if(br != null) br.close(); // Always executes<br>
        }</span><br>
        <br>
        // Modern try-with-resources (Java 7+)<br>
        <span class="code">try(BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {<br>
        &nbsp;&nbsp;// Auto-closed in finally<br>
        }</span><br>
        <br>
        <strong>When Not Executed</strong>:<br>
        - System.exit()<br>
        - JVM crash<br>
        - Infinite loop in try/catch<br>
        <br>
        <strong>Memory Trick</strong>:<br>
        - "finally" is like a janitor that always cleans up, no matter what mess happens</p>
    </div>

    <div class="unit">
        <h2>Unit 3: I/O and Multithreading</h2>

        <p class="question">1. What are the fundamental concepts of Input/Output (I/O) in Java, and why is it essential in programming?</p>
        <p class="answer">- <strong>Core Concepts</strong>:<br>
        1. Streams: Data flows (InputStream/OutputStream for bytes, Reader/Writer for chars)<br>
        2. Sources/Destinations: Files, network, memory, system I/O<br>
        3. Buffering: Improves performance by reducing native calls<br>
        4. Serialization: Converting objects to byte streams<br>
        <br>
        <strong>Why Essential</strong>:<br>
        - Persistent storage (files/databases)<br>
        - Inter-process communication<br>
        - Network operations<br>
        - Configuration/logging<br>
        <br>
        <strong>Memory Tip</strong>:<br>
        - Input = Reading (like a scanner)<br>
        - Output = Writing (like a printer)</p>

        <p class="question">2. Discuss the usage of byte streams in Java for reading and writing data, including their advantages and limitations.</p>
        <p class="answer">- <strong>Byte Stream Classes</strong>:<br>
        - InputStream/OutputStream (abstract base)<br>
        - FileInputStream/FileOutputStream (files)<br>
        - ByteArrayInputStream/ByteArrayOutputStream (memory)<br>
        - BufferedInputStream/BufferedOutputStream (buffering)<br>
        <br>
        <strong>Advantages</strong>:<br>
        1. Universal (handles any data type)<br>
        2. Efficient for binary data (images, serialized objects)<br>
        3. Lower-level control<br>
        <br>
        <strong>Limitations</strong>:<br>
        1. Not ideal for text (chars ≠ bytes in encodings)<br>
        2. Manual buffering often needed<br>
        <br>
        <strong>Example</strong>:<br>
        <span class="code">try(FileInputStream fis = new FileInputStream("file.bin");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;BufferedInputStream bis = new BufferedInputStream(fis)) {<br>
        &nbsp;&nbsp;int data;<br>
        &nbsp;&nbsp;while((data = bis.read()) != -1) { /* process byte */ }<br>
        }</span></p>

        <p class="question">3. Explain how to read and write data using byte streams in Java, and discuss the importance of closing files automatically.</p>
        <p class="answer">- <strong>Reading</strong>:<br>
        <span class="code">try(InputStream is = new FileInputStream("input.bin")) {<br>
        &nbsp;&nbsp;byte[] buffer = new byte[1024];<br>
        &nbsp;&nbsp;int bytesRead;<br>
        &nbsp;&nbsp;while((bytesRead = is.read(buffer)) != -1) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;// Process buffer[0..bytesRead-1]<br>
        &nbsp;&nbsp;}<br>
        }</span><br>
        <br>
        - <strong>Writing</strong>:<br>
        <span class="code">try(OutputStream os = new FileOutputStream("output.bin")) {<br>
        &nbsp;&nbsp;byte[] data = ...;<br>
        &nbsp;&nbsp;os.write(data);<br>
        }</span><br>
        <br>
        - <strong>Auto-closing Importance</strong>:<br>
        1. Prevents resource leaks<br>
        2. Ensures buffers are flushed<br>
        3. Releases file locks immediately<br>
        4. Try-with-resources (Java 7+) is preferred<br>
        <br>
        <strong>Memory Tip</strong>:<br>
        - Always use try-with-resources for streams - it's like having an automatic door closer</p>

        <p class="question">4. Describe the role of character-based streams in Java I/O and how they differ from byte streams.</p>
        <p class="answer">- <strong>Character Streams</strong>:<br>
        - Reader/Writer hierarchy (vs InputStream/OutputStream)<br>
        - Handle text data with proper character encoding<br>
        - Common implementations:<br>
        &nbsp;&nbsp;• FileReader/FileWriter<br>
        &nbsp;&nbsp;• BufferedReader/BufferedWriter<br>
        &nbsp;&nbsp;• InputStreamReader/OutputStreamWriter (bridge to byte streams)<br>
        <br>
        - <strong>Key Differences</strong>:<br>
        | Feature        | Byte Streams          | Character Streams     |<br>
        |---------------|----------------------|----------------------|<br>
        | Data Unit     | 8-bit bytes           | 16-bit Unicode chars  |<br>
        | Best For      | Binary data           | Text data            |<br>
        | Encoding      | Raw bytes             | Handles encodings    |<br>
        | Classes       | InputStream/OutputStream | Reader/Writer     |<br>
        <br>
        <strong>Example</strong>:<br>
        <span class="code">try(BufferedReader br = new BufferedReader(new FileReader("text.txt"))) {<br>
        &nbsp;&nbsp;String line;<br>
        &nbsp;&nbsp;while((line = br.readLine()) != null) { /* process line */ }<br>
        }</span></p>

        <p class="question">5. How do you perform file I/O using character streams in Java, specifically using a FileWriter and a FileReader?</p>
        <p class="answer">- <strong>FileReader</strong> (Reading):<br>
        <span class="code">try(FileReader fr = new FileReader("input.txt");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;BufferedReader br = new BufferedReader(fr)) {<br>
        &nbsp;&nbsp;String line;<br>
        &nbsp;&nbsp;while((line = br.readLine()) != null) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(line);<br>
        &nbsp;&nbsp;}<br>
        }</span><br>
        <br>
        - <strong>FileWriter</strong> (Writing):<br>
        <span class="code">try(FileWriter fw = new FileWriter("output.txt");<br>
        &nbsp;&nbsp;&nbsp;&nbsp;BufferedWriter bw = new BufferedWriter(fw)) {<br>
        &nbsp;&nbsp;bw.write("Hello World");<br>
        &nbsp;&nbsp;bw.newLine(); // Platform-independent line separator<br>
        }</span><br>
        <br>
        - <strong>Key Points</strong>:<br>
        1. Always specify charset when important: <code class="code">new InputStreamReader(fis, StandardCharsets.UTF_8)</code><br>
        2. Buffering significantly improves performance<br>
        3. <code class="code">readLine()</code> is convenient for text processing<br>
        4. Writers handle platform-specific line endings automatically</p>

        <!-- Continuing with questions 6-15 from Unit 3 -->
        <p class="question">6. What are the basics of multithreading in Java, and why is it beneficial for concurrent programming?</p>
        <p class="answer">- <strong>Basics</strong>:<br>
        1. Thread: Lightweight sub-process<br>
        2. Multithreading: Multiple threads run concurrently<br>
        3. Ways to create:<br>
        &nbsp;&nbsp;a) Extend Thread class<br>
        &nbsp;&nbsp;b) Implement Runnable<br>
        &nbsp;&nbsp;c) Java 8+: Lambda expressions<br>
        <br>
        - <strong>Benefits</strong>:<br>
        1. Better CPU utilization<br>
        2. Improved responsiveness<br>
        3. Simplified modeling of concurrent tasks<br>
        4. Parallel processing on multi-core systems<br>
        <br>
        - <strong>Example</strong>:<br>
        <span class="code">Thread t = new Thread(() -> {<br>
        &nbsp;&nbsp;System.out.println("Running in thread");<br>
        });<br>
        t.start();</span><br>
        <br>
        - <strong>Memory Tip</strong>:<br>
        Threads are like workers in a kitchen - multiple can work simultaneously</p>

        <!-- Additional questions 7-15 would follow the same pattern -->
        
    </div>

    <div class="unit">
        <h2>Unit 4: Swing GUI and JDBC</h2>

        <p class="question">1. What are the fundamental components of Swing in Java, and how are they used in GUI development?</p>
        <p class="answer">- <strong>Core Components</strong>:<br>
        1. Top-Level Containers: JFrame, JDialog, JApplet<br>
        2. Intermediate Containers: JPanel, JScrollPane, JTabbedPane<br>
        3. Basic Controls: JButton, JLabel, JTextField, JTextArea<br>
        4. Advanced Components: JTable, JTree, JFileChooser<br>
        <br>
        - <strong>GUI Development</strong>:<br>
        1. Create JFrame as main window<br>
        2. Add components to content pane<br>
        3. Set layout managers<br>
        4. Add event listeners<br>
        <br>
        - <strong>Example</strong>:<br>
        <span class="code">JFrame frame = new JFrame("My App");<br>
        frame.setLayout(new FlowLayout());<br>
        frame.add(new JButton("Click"));<br>
        frame.setSize(300,200);<br>
        frame.setVisible(true);</span></p>

        <!-- Additional questions 2-15 would follow the same pattern -->
        
        <p class="question">15. Provide a step-by-step explanation of connecting to a database using JDBC and executing SQL queries.</p>
        <p class="answer">- <strong>JDBC Steps</strong>:<br>
        1. Load Driver: <code class="code">Class.forName("com.mysql.jdbc.Driver");</code><br>
        2. Establish Connection:<br>
        <span class="code">Connection con = DriverManager.getConnection(<br>
        &nbsp;&nbsp;"jdbc:mysql://localhost:3306/mydb", "user", "pass");</span><br>
        3. Create Statement:<br>
        <span class="code">Statement stmt = con.createStatement();</span><br>
        4. Execute Query:<br>
        <span class="code">ResultSet rs = stmt.executeQuery("SELECT * FROM employees");</span><br>
        5. Process Results:<br>
        <span class="code">while(rs.next()) {<br>
        &nbsp;&nbsp;String name = rs.getString("name");<br>
        &nbsp;&nbsp;// process row<br>
        }</span><br>

6. Close Resources (in finally block or try-with-resources)<br>
        <br>
        - <strong>Best Practices</strong>:<br>
        1. Use PreparedStatement for parameters<br>
        2. Always close resources<br>
        3. Use connection pooling in production<br>
        4. Handle SQLExceptions properly<br>
        <br>
        - <strong>Memory Tip</strong>:<br>
        JDBC workflow: Driver → Connection → Statement → Execute → Result → Close</p>
    </div>
</body>
</html>
